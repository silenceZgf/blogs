# Perl 进程管理
> Linux 系统中, 每执行一条命令或运行一个程序,都会产生一个主进程, 在主进程运行的时候,也有可能会产生多个子进程, 我们可以通过命令: ps -ef | grep xxx 来查看进程相关的信息.但是对于有些命令, 执行速度很快, 比如说ls /, 这样我们通过ps  -ef 并不能看到与ls 相关的进程信息, 虽然看不到, 但是这不能表示ls 在执行的时候不会产生进程, 只是因为执行速度太快,难以捕获罢了.

perl 对进程的管理功能也是比较强大的, 但是笔者用perl 只是为了写一些脚本程序, 所以只需要掌握以下内容就行了:
* perl 程序中调用系统命令或执行其它系统脚本
* perl 向其它进程发送信号(关闭其它进程)
* perl 接收其它进程发送的信号(被Ctrl+C 中断程序执行)


# 1. 调用系统命令或执行其它程序
perl 语言中调用执行系统命令或其它程序时会创建一个新的子进程, 执行命令有三种模式: system, qx, exec
* 父进程: perl 脚本所占用的进程为父进程, 又称主进程
* 子进程: perl 脚本调用系统命令或执行其它程序占用的进程

| 命令 | 格式 | 描述 |
| :--- | :--- | :--- |
| system | 主进程休眠,启动子进程执行其它程序,不捕获输出 | 返回状态码, 0 为成功, 其它为失败 |
| qx / `` | 主进程休眠, 启动子进程执行其它程序, 捕获输出 | 返回子进程标准输出的内容 |
| exec | 主进程结束, 启动子进程执行其它程序, 不捕获输出| 无返回值 |

## 1.1 system
* 命令格式1: system " xxx "; 双引号中的$ 引用的是perl标量, \$ 引用的是shell 的系统环境变量
* 命令格式2: system ' xxx '; 单引号中的$ 引用的是shell 中的环境变量, \$ 无实用意义

```perl

```

## 1.2 qx
反引号`` 是qx 的简写形式, qx 可以用(), "", '' 等作为限定符, 返回值可由标量或数组进行捕获.在标量上下文中输出的内容为一个字符串, 在数组上下文中, 按换行符分隔为一个一个的元素.

* 命令格式1:  $line = `xxx`; 反引号中$ 引用的是perl 标量, \$ 引用的是shell 系统环境变量
* 命令格式2: $line = qx ' xxx '; qx 单引号中$引用的是shell 系统环境变量, \$ 无实用意义 
* 命令格式3: @lines = qx " xxx "; qx 双引号中$引用的是perl 变量, \$ 无实用意义
* 命令格式4: @lines = qx ( xxx ); qx 双引号中$引用的是perl 变量, \$ 无实用意义

```perl

```


# 2. 向其它进程发送信号
* 命令格式: kill sigInt, pid1 pid2 ...;
* sigInt: 信号数字, 常用的是9, 强制杀死进程
* pid: 进程id , 可同时杀死多个进程
* 返回成功杀死进程的数量

```perl
kill 9, 5161 6161;
```

# 3. 接收其它进程发送的信号
* perl 程序运行时, 也会启动一个进程, 所以perl 进程也可以接收其它进程发送的信号
* perl 内置了%SIG 存储了perl 可接收的所有信号参数, 存储格式为: key=method
* 我们只需要给对应的key对应的value设置相应的方法即可,这样当程序接收到信号,就会执行对应的方法.
* 注意: 当perl 主程序接收到相应的信号之后,会暂时中断目前正在执行的流程, 而去执行信号对应的方法, 当方法完成之后,再回到原来执行的位置,继续执行.

















